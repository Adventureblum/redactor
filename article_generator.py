#!/usr/bin/env python3
"""
G√©n√©rateur d'articles avec architecture Orchestrateur + 3 Agents sp√©cialis√©s
- Agent Hook: Introduction ultra-performante avec highlight
- Agent R√©dacteur: D√©veloppement (appel√© X fois selon sections)
- Agent Conclusion+CTA: Synth√®se + call-to-action avec faux highlight
"""

import json
import os
import sys
import glob
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import openai
from openai import OpenAI

# Configuration OpenAI
client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

def _find_consigne_file() -> str:
    """Trouve automatiquement le fichier de consigne dans le dossier static"""
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    STATIC_DIR = os.path.join(BASE_DIR, "static")
    
    consigne_pattern = os.path.join(STATIC_DIR, "consigne*.json")
    consigne_files = glob.glob(consigne_pattern)
    
    if not consigne_files:
        raise FileNotFoundError(f"‚ùå Aucun fichier de consigne trouv√© dans {STATIC_DIR}/ (pattern: consigne*.json)")
    
    if len(consigne_files) == 1:
        found_file = consigne_files[0]
        print(f"üìÅ Fichier de consigne d√©tect√©: {os.path.basename(found_file)}")
        return found_file
    
    # Si plusieurs fichiers trouv√©s, prendre le plus r√©cent
    consigne_files.sort(key=os.path.getmtime, reverse=True)
    most_recent = consigne_files[0]
    print(f"üìÅ Plusieurs fichiers de consigne trouv√©s, utilisation du plus r√©cent: {os.path.basename(most_recent)}")
    print(f"   Autres fichiers ignor√©s: {', '.join([os.path.basename(f) for f in consigne_files[1:]])}")
    return most_recent

@dataclass
class ContexteArticle:
    """Contexte transmis entre les agents"""
    contenu_precedent: str = ""
    mots_cles_utilises: List[str] = None
    mots_cles_restants: List[str] = None
    mots_total_rediges: int = 0
    tone_etabli: str = ""
    fil_narratif: str = ""
    progression_general_specifique: str = ""
    
    def __post_init__(self):
        if self.mots_cles_utilises is None:
            self.mots_cles_utilises = []
        if self.mots_cles_restants is None:
            self.mots_cles_restants = []

class OrchestrateurArticle:
    def __init__(self, consigne_path: str):
        self.consigne_path = consigne_path
        self.consigne_data = self.load_consigne()
        
    def load_consigne(self) -> Dict:
        """Charge le fichier consigne.json"""
        try:
            with open(self.consigne_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"‚ùå Fichier {self.consigne_path} non trouv√©.")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"‚ùå Erreur JSON dans {self.consigne_path}: {e}")
            sys.exit(1)
    
    def save_consigne(self):
        """Sauvegarde le fichier consigne.json"""
        with open(self.consigne_path, 'w', encoding='utf-8') as f:
            json.dump(self.consigne_data, f, ensure_ascii=False, indent=4)
    
    def prepare_keywords_list(self, top_keywords: str) -> List[str]:
        """Pr√©pare la liste des mots-cl√©s depuis la cha√Æne top_keywords"""
        return [kw.strip() for kw in top_keywords.split(',') if kw.strip()]
    
    def calculate_keyword_budget(self, total_words: int) -> int:
        """Calcule le nombre de mots-cl√©s √† int√©grer (1 top_keyword / 4-5 mots)"""
        return total_words // 5  # On prend la moyenne (1/5)
    
    def distribute_keywords(self, keywords: List[str], sections_count: int) -> Dict[str, List[str]]:
        """Distribue les mots-cl√©s entre introduction, sections et conclusion"""
        total_kw = len(keywords)
        
        # R√©partition: 30% intro, 60% sections (√©quitable), 10% conclusion
        intro_kw = max(1, int(total_kw * 0.3))
        conclusion_kw = max(1, int(total_kw * 0.1))
        sections_kw = total_kw - intro_kw - conclusion_kw
        
        kw_per_section = sections_kw // sections_count if sections_count > 0 else 0
        
        distribution = {
            'introduction': keywords[:intro_kw],
            'sections': [],
            'conclusion': keywords[-conclusion_kw:] if conclusion_kw > 0 else []
        }
        
        # Distribution par section
        start_idx = intro_kw
        for i in range(sections_count):
            end_idx = start_idx + kw_per_section
            distribution['sections'].append(keywords[start_idx:end_idx])
            start_idx = end_idx
        
        return distribution
    
    def agent_hook(self, query_data: Dict, contexte: ContexteArticle, keywords_assignes: List[str]) -> str:
        """Agent Hook - Introduction ultra-performante avec highlight"""
        plan = query_data.get('generated_article_plan', {})
        intro_notes = plan.get('introduction_notes', {})
        nb_mots = query_data['plan']['introduction']['longueur']
        
        prompt = f"""Tu es l'Agent Hook, sp√©cialiste des introductions ultra-performantes.

MISSION: R√©diger une introduction captivante de {nb_mots} mots EXACTEMENT.

DONN√âES CONTEXTUELLES:
- Requ√™te: "{query_data['text']}"
- Titre SEO: {plan.get('SEO Title', '')}
- Angle diff√©renciant: {query_data.get('selected_differentiating_angle', '')}

PROGRESSION G√âN√âRALE ‚Üí SP√âCIFIQUE:
Tu ouvres l'article avec une vue d'ensemble/probl√©matique g√©n√©rale avant de cibler.

MOTS-CL√âS ASSIGN√âS √Ä TOI (int√©grer naturellement):
{', '.join(keywords_assignes)}

HIGHLIGHT OBLIGATOIRE √Ä INT√âGRER:
- URL: {self.consigne_data.get('highlight', '')}
- Contexte sugg√©r√©: {intro_notes.get('highlight_integration', '')}
- Ancrage sugg√©r√©: {intro_notes.get('suggested_anchor_text', '')}

SECTIONS √Ä ANNONCER:
{chr(10).join([f"- {section['section_title']}" for section in plan.get('sections', [])])}

CONTRAINTES STRICTES:
1. EXACTEMENT {nb_mots} mots
2. Hook ultra-engageant (question, statistique, fait surprenant)
3. Int√©grer le lien highlight NATURELLEMENT 
4. Annoncer le plan avec les sections exactes
5. Ton professionnel mais accessible
6. Score Flesch 60-70 (accessible)

STRUCTURE OPTIMALE:
- Hook puissant (probl√©matique/questionnement)
- Contextualisation g√©n√©rale
- Int√©gration naturelle du highlight
- Annonce du plan d√©taill√©
- Transition vers le d√©veloppement

R√©dige cette introduction ultra-performante."""

        try:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7,
                max_tokens=800
            )
            
            introduction = response.choices[0].message.content.strip()
            
            # Mise √† jour du contexte
            contexte.contenu_precedent = introduction
            contexte.mots_total_rediges += len(introduction.split())
            contexte.tone_etabli = "professionnel accessible"
            contexte.fil_narratif = "Introduction hook √©tablie - Vue d'ensemble donn√©e"
            contexte.progression_general_specifique = "Phase 1: G√©n√©ral (probl√©matique globale √©tablie)"
            
            return introduction
            
        except Exception as e:
            print(f"‚ùå Erreur Agent Hook: {e}")
            return ""
    
    def agent_redacteur(self, query_data: Dict, contexte: ContexteArticle, 
                       section_data: Dict, section_index: int, keywords_assignes: List[str]) -> str:
        """Agent R√©dacteur - D√©veloppement d'une section sp√©cifique"""
        
        # Calcul des mots par section
        word_count_total = query_data.get('word_count', 1121)
        intro_words = query_data['plan']['introduction']['longueur']
        conclusion_words = query_data['plan']['conclusion']['longueur']
        development_words = word_count_total - intro_words - conclusion_words  
        
        plan = query_data.get('generated_article_plan', {})
        sections_count = len(plan.get('sections', []))
        mots_par_section = development_words // sections_count if sections_count > 0 else 300
        
        # Progression g√©n√©ral ‚Üí sp√©cifique
        if section_index == 0:
            niveau_specifique = "Niveau 2: Plus cibl√© que l'introduction"
        elif section_index == 1:
            niveau_specifique = "Niveau 3: Encore plus sp√©cifique et d√©taill√©"
        else:
            niveau_specifique = f"Niveau {section_index + 2}: Tr√®s d√©taill√© et pratique"
        
        prompt = f"""Tu es l'Agent R√©dacteur, sp√©cialiste du d√©veloppement structur√©.

MISSION: R√©diger la section "{section_data['section_title']}" de {int(mots_par_section)} mots EXACTEMENT.

CONTEXTE PR√âC√âDENT:
{contexte.contenu_precedent[-1000:]}  # Garder les 1000 derniers caract√®res

PROGRESSION G√âN√âRAL ‚Üí SP√âCIFIQUE:
{niveau_specifique}
Fils narratif actuel: {contexte.fil_narratif}

PLAN D√âTAILL√â DE CETTE SECTION:
- Titre: {section_data['section_title']}
- Type de snippet: {section_data.get('snippet_type', 'None')}
- Placement: {section_data.get('placement', 'middle')}
- Sous-sections OBLIGATOIRES:
{chr(10).join([f"  ‚Ä¢ {sub['subsection_title']}" for sub in section_data.get('subsections', [])])}

MOTS-CL√âS ASSIGN√âS √Ä CETTE SECTION:
{', '.join(keywords_assignes)}

CONTRAINTES STRICTES:
1. EXACTEMENT {int(mots_par_section)} mots
2. Traiter TOUTES les sous-sections list√©es
3. Transition fluide depuis le contenu pr√©c√©dent
4. Ton coh√©rent: {contexte.tone_etabli}  
5. Structure H2 + H3 pour sous-sections
6. Score Flesch 60-70
7. √âviter la sur-optimisation des mots-cl√©s d√©j√† utilis√©s: {', '.join(contexte.mots_cles_utilises[-10:])}

FORMAT ATTENDU:
## {section_data['section_title']}

### {section_data.get('subsections', [{}])[0].get('subsection_title', 'Premi√®re sous-section')}
[Contenu d√©taill√©...]

### [Autres sous-sections...]
[Contenu...]

R√©dige cette section en respectant la progression du g√©n√©ral au sp√©cifique."""

        try:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7,
                max_tokens=1500
            )
            
            section_content = response.choices[0].message.content.strip()
            
            # Mise √† jour du contexte
            contexte.contenu_precedent += f"\n\n{section_content}"
            contexte.mots_total_rediges += len(section_content.split())
            contexte.fil_narratif = f"Section '{section_data['section_title']}' compl√©t√©e - {niveau_specifique}"
            contexte.progression_general_specifique = niveau_specifique
            
            return section_content
            
        except Exception as e:
            print(f"‚ùå Erreur Agent R√©dacteur section {section_index + 1}: {e}")
            return ""
    
    def agent_conclusion_cta(self, query_data: Dict, contexte: ContexteArticle, keywords_assignes: List[str]) -> str:
        """Agent Conclusion+CTA - Synth√®se + call-to-action ultra pertinent"""
        plan = query_data.get('generated_article_plan', {})
        nb_mots = query_data['plan']['conclusion']['longueur']
        
        # G√©n√©ration d'un faux highlight contextuel
        sujet_principal = query_data['text'].replace('qu est ce que', '').replace('comment', '').strip()
        faux_highlight = f"https://formation-{sujet_principal.replace(' ', '-').replace('d-', '').replace('int√©rieur', 'interieur')}.fr"
        
        prompt = f"""Tu es l'Agent Conclusion+CTA, sp√©cialiste des finales ultra-persuasives.

MISSION: R√©diger une conclusion de {nb_mots} mots EXACTEMENT avec CTA int√©gr√©.

ARTICLE COMPLET PR√âC√âDENT:
{contexte.contenu_precedent[-2000:]}  # Garder les 2000 derniers caract√®res

DONN√âES CONTEXTUELLES:
- Requ√™te initiale: "{query_data['text']}"
- Titre: {plan.get('SEO Title', '')}
- Progression atteinte: {contexte.progression_general_specifique}

MOTS-CL√âS ASSIGN√âS (√©viter sur-optimisation):
{', '.join(keywords_assignes)}

FAUX HIGHLIGHT √Ä INT√âGRER:
{faux_highlight}

CONTRAINTES STRICTES:
1. EXACTEMENT {nb_mots} mots
2. Synth√®se claire des points cl√©s abord√©s
3. R√©ponse d√©finitive √† la question initiale
4. CTA ultra-pertinent avec le faux highlight
5. Ton conclusif et actionnable
6. Score Flesch 60-70
7. √âviter r√©p√©tition des mots-cl√©s sur-utilis√©s: {', '.join(contexte.mots_cles_utilises[-15:])}

STRUCTURE OPTIMALE:
- R√©capitulatif des points essentiels (synth√®se)
- R√©ponse claire et d√©finitive √† la question
- Conseil pratique ou perspective d'avenir
- CTA naturel avec le faux highlight
- Fermeture inspirante

PROGRESSION G√âN√âRAL ‚Üí SP√âCIFIQUE:
Tu conclus en transformant toute l'information en ACTION CONCR√àTE pour le lecteur.

R√©dige cette conclusion ultra-persuasive avec CTA int√©gr√©."""

        try:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7,
                max_tokens=800
            )
            
            conclusion = response.choices[0].message.content.strip()
            return conclusion
            
        except Exception as e:
            print(f"‚ùå Erreur Agent Conclusion+CTA: {e}")
            return ""
    
    def orchestrer_article(self, query_id: int) -> Dict:
        """Orchestrateur principal - Coordonne les 3 agents"""
        query_data = self.get_query_data(query_id)
        if not query_data or 'generated_article_plan' not in query_data:
            return {}
        
        print(f"\nüéº ORCHESTRATION pour ID {query_id}: '{query_data['text']}'")
        
        # Pr√©paration
        keywords = self.prepare_keywords_list(query_data.get('top_keywords', ''))
        plan = query_data.get('generated_article_plan', {})
        sections = plan.get('sections', [])
        
        # Distribution des mots-cl√©s
        kw_distribution = self.distribute_keywords(keywords, len(sections))
        
        contexte = ContexteArticle()
        contexte.mots_cles_restants = keywords.copy()
        
        print(f"   üìä Mots-cl√©s distribu√©s: Intro({len(kw_distribution['introduction'])}), Sections({len(kw_distribution['sections'])}), Conclusion({len(kw_distribution['conclusion'])})")
        
        # 1. Agent Hook - Introduction
        print("   üéØ Agent Hook: G√©n√©ration introduction...")
        introduction = self.agent_hook(query_data, contexte, kw_distribution['introduction'])
        
        # 2. Agent R√©dacteur - Sections (appel√© X fois)
        sections_content = []
        for i, section in enumerate(sections):
            section_keywords = kw_distribution['sections'][i] if i < len(kw_distribution['sections']) else []
            print(f"   ‚úçÔ∏è  Agent R√©dacteur: Section {i+1}/{len(sections)} - '{section['section_title']}'...")
            section_content = self.agent_redacteur(query_data, contexte, section, i, section_keywords)
            sections_content.append(section_content)
        
        # 3. Agent Conclusion+CTA
        print("   üéØ Agent Conclusion+CTA: G√©n√©ration finale...")
        conclusion = self.agent_conclusion_cta(query_data, contexte, kw_distribution['conclusion'])
        
        # Assemblage final
        article_complet = {
            'title': plan.get('SEO Title', f"Article sur {query_data['text']}"),
            'introduction': introduction,
            'sections': sections_content,
            'conclusion': conclusion,
            'word_count': len(f"{introduction} {' '.join(sections_content)} {conclusion}".split()),
            'generated_date': "2025-06-30",
            'generation_method': 'orchestrateur_3_agents',
            'keyword_distribution': kw_distribution
        }
        
        return article_complet
    
    def get_query_data(self, query_id: int) -> Optional[Dict]:
        """R√©cup√®re les donn√©es d'une requ√™te par son ID"""
        for query in self.consigne_data.get('queries', []):
            if query['id'] == query_id:
                return query
        return None
    
    def list_available_queries(self) -> List[Dict]:
        """Liste toutes les requ√™tes disponibles avec leur statut"""
        queries = []
        for query in self.consigne_data.get('queries', []):
            has_plan = 'generated_article_plan' in query
            has_article = 'generated_article' in query
            status = "üü¢ Complet" if has_article else "üü° Plan pr√™t" if has_plan else "üî¥ Non trait√©"
            queries.append({
                'id': query['id'],
                'text': query['text'],
                'status': status,
                'has_plan': has_plan,
                'has_article': has_article
            })
        return queries
    
    def select_queries_to_process(self) -> List[int]:
        """Interface utilisateur pour s√©lectionner les requ√™tes √† traiter"""
        queries = self.list_available_queries()
        
        print("\nüìã REQU√äTES DISPONIBLES:")
        print("=" * 80)
        for q in queries:
            print(f"ID {q['id']:2d} | {q['status']} | {q['text']}")
        
        print("\nüí° Instructions:")
        print("- Tapez un ID pour traiter une seule requ√™te: 5")
        print("- Tapez plusieurs IDs s√©par√©s par des virgules: 1,3,5")
        print("- Tapez une plage d'IDs: 1-5")
        print("- Tapez 'all' pour traiter toutes les requ√™tes avec plan")
        print("- Tapez 'q' pour quitter")
        
        while True:
            user_input = input("\nüéØ Votre s√©lection: ").strip().lower()
            
            if user_input == 'q':
                print("üëã Au revoir!")
                sys.exit(0)
            
            if user_input == 'all':
                return [q['id'] for q in queries if q['has_plan'] and not q['has_article']]
            
            try:
                selected_ids = []
                
                # Gestion des plages (1-5)
                if '-' in user_input and user_input.count('-') == 1:
                    start, end = map(int, user_input.split('-'))
                    selected_ids = list(range(start, end + 1))
                
                # Gestion des listes (1,3,5)
                elif ',' in user_input:
                    selected_ids = [int(x.strip()) for x in user_input.split(',')]
                
                # ID unique
                else:
                    selected_ids = [int(user_input)]
                
                # Validation
                valid_ids = [q['id'] for q in queries]
                invalid_ids = [id for id in selected_ids if id not in valid_ids]
                
                if invalid_ids:
                    print(f"‚ùå IDs invalides: {invalid_ids}")
                    continue
                
                # V√©rification des plans
                no_plan_ids = [id for id in selected_ids 
                              if not any(q['id'] == id and q['has_plan'] for q in queries)]
                
                if no_plan_ids:
                    print(f"‚ö†Ô∏è  Les IDs suivants n'ont pas de plan g√©n√©r√©: {no_plan_ids}")
                    continue_anyway = input("Continuer quand m√™me? (y/N): ").lower() == 'y'
                    if not continue_anyway:
                        continue
                
                return selected_ids
                
            except ValueError:
                print("‚ùå Format invalide. Utilisez des nombres, des virgules ou des tirets.")
    
    def process_queries(self, query_ids: List[int]):
        """Traite une liste de requ√™tes avec l'orchestrateur"""
        print(f"\nüéº ORCHESTRATION DE {len(query_ids)} REQU√äTE(S): {query_ids}")
        
        for query_id in query_ids:
            try:
                article = self.orchestrer_article(query_id)
                
                if article:
                    # Int√©gration dans consigne.json
                    for query in self.consigne_data['queries']:
                        if query['id'] == query_id:
                            query['generated_article'] = article
                            break
                    
                    print(f"   ‚úÖ Article orchestr√© pour ID {query_id} ({article['word_count']} mots)")
                else:
                    print(f"   ‚ùå √âchec orchestration pour ID {query_id}")
                    
            except Exception as e:
                print(f"   ‚ùå Erreur lors de l'orchestration ID {query_id}: {e}")
        
        # Sauvegarde
        try:
            self.save_consigne()
            print(f"\nüíæ Fichier {self.consigne_path} mis √† jour avec succ√®s!")
        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde: {e}")

def main():
    """Fonction principale"""
    print("üéº G√âN√âRATEUR D'ARTICLES - ORCHESTRATEUR + 3 AGENTS")
    print("=" * 60)
    print("üéØ Agent Hook | ‚úçÔ∏è  Agent R√©dacteur | üéØ Agent Conclusion+CTA")
    
    # V√©rification de la cl√© API OpenAI
    if not os.getenv('OPENAI_API_KEY'):
        print("‚ùå Variable d'environnement OPENAI_API_KEY manquante.")
        print("Ajoutez votre cl√© API OpenAI:")
        print("export OPENAI_API_KEY='your-api-key-here'")
        sys.exit(1)
    
    # Auto-d√©tection du fichier consigne avec identifiants uniques
    try:
        consigne_path = _find_consigne_file()
    except FileNotFoundError as e:
        print(str(e))
        print("üí° Assurez-vous qu'un fichier consigne*.json existe dans le dossier static/")
        sys.exit(1)
    
    # Initialisation de l'orchestrateur
    orchestrateur = OrchestrateurArticle(consigne_path)
    
    # S√©lection et traitement
    try:
        selected_ids = orchestrateur.select_queries_to_process()
        if selected_ids:
            orchestrateur.process_queries(selected_ids)
        else:
            print("‚ÑπÔ∏è  Aucune requ√™te s√©lectionn√©e.")
    
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Arr√™t demand√© par l'utilisateur.")
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")

if __name__ == "__main__":
    main()